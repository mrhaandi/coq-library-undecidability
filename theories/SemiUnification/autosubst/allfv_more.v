(* Andrej: the contents of this file could be incorporated into autosubst generated files 
Here, I use ssreflect for convenience. Actual generated proofs should be terms.

allfv : evaluation of a predicate on all free variables
*)

Require Import Undecidability.SemiUnification.autosubst.unscoped.
Require Import Undecidability.SemiUnification.autosubst.pts.
Require Import Undecidability.SemiUnification.autosubst.pts_more.

Require Import ssreflect.

(* such that simpl evaluates funcomp f g x *)
Arguments funcomp {X Y Z} _ _ _ /.
(* such that simpl evaluates id x*)
Arguments unscoped.id _ _/.

(* evaluates propositional predicate p on all free variables *)
Fixpoint allfv_term (p: nat -> Prop) (P: term) :=
  match P with
  | var x => p x
  | const _ => True 
  | app P Q => allfv_term p P /\ allfv_term p Q
  | lam P Q => allfv_term p P /\ allfv_term (scons True p) Q
  | Pi P Q => allfv_term p P /\ allfv_term (scons True p) Q
  end.

(* decidable allfv_term on decidable predicates *)
(* TODO move to autosubst? *)
Lemma allfv_term_dec (p: nat -> Prop) (P: term) : 
  (forall x, {p x} + {not (p x)}) ->
  {allfv_term p P} + {not (allfv_term p P)}.
Proof.
  elim: P p.
  - move=> >. by apply.
  - move=> *. by left.
  - move=> P IHP Q IHQ p Hp /=.
    move: (IHP _ Hp) (IHQ _ Hp); clear; by firstorder done.
  - move=> P IHP Q IHQ p Hp /=.
    have H'p: forall x : nat, {(scons True p) x} + {not ((scons True p) x)} by (case; [left |]).
    move: (IHP _ Hp) (IHQ _ H'p); clear; by firstorder done.
  - move=> P IHP Q IHQ p Hp /=.
    have H'p: forall x : nat, {(scons True p) x} + {not ((scons True p) x)} by (case; [left |]).
    move: (IHP _ Hp) (IHQ _ H'p); clear; by firstorder done.
Qed.

(* TODO could be generated by autosubst *)
(* allfv on trivial predicate *)
Lemma allfv_term_triv {p: nat -> Prop} {P: term}: 
  (forall x, p x) -> allfv_term p P.
Proof.
  elim: P p.
  - move=> >. by apply.
  - done.
  - move=> P IHP Q IHQ p ? /=. 
    constructor; [by apply: IHP | by apply: IHQ].
  - move=> P IHP Q IHQ p ? /=. constructor; [by apply: IHP |].
    apply: IHQ. by case.
  - move=> P IHP Q IHQ p ? /=. constructor; [by apply: IHP |].
    apply: IHQ. by case.
Qed.

(* TODO could be generated by autosubst *)
(* allfv monotonicity *)
Lemma allfv_term_impl {p1 p2: nat -> Prop} {P: term}: 
  (forall x, p1 x -> p2 x) -> allfv_term p1 P -> allfv_term p2 P.
Proof.
  elim: P p1 p2.
  - move=> >. by apply.
  - done.
  - by move=> P IHP Q IHQ p1 p2 H /= [/(IHP _ _ H) ? /(IHQ _ _ H) ?].
  - move=> P IHP Q IHQ p1 p2 H /= [/IHP {}IHP /IHQ {}IHQ].
    constructor; first by apply: IHP.
    apply: IHQ. by case.
  - move=> P IHP Q IHQ p1 p2 H /= [/IHP {}IHP /IHQ {}IHQ].
    constructor; first by apply: IHP.
    apply: IHQ. by case.
Qed.


(* TODO could be generated by autosubst *)
(* extensionality principle on allfv_term *)
Lemma ext_allfv_term {p1 p2 P}: (forall x, p1 x <-> p2 x) -> allfv_term p1 P <-> allfv_term p2 P.
Proof. move=> H. by constructor; apply: allfv_term_impl; move=> ? /H. Qed.

Lemma allfv_allfv_term_impl {p1 p2: nat -> Prop} {P: term} : 
  allfv_term (fun x => p1 x -> p2 x) P -> allfv_term p1 P -> allfv_term p2 P.
Proof.
  elim: P p1 p2.
  - move=> >. by apply.
  - done.
  - move=> P IHP Q IHQ p1 p2 /= [HP HQ].
    by move=> [/(IHP _ _ HP) + /(IHQ _ _ HQ)].
  - move=> P IHP Q IHQ p1 p2 /= [H1P H1Q] [H2P H2Q].
    constructor; first by apply: (IHP _ _ H1P H2P).
    apply: IHQ; last by eassumption.
    apply: allfv_term_impl H1Q. by case.
  - move=> P IHP Q IHQ p1 p2 /= [H1P H1Q] [H2P H2Q].
    constructor; first by apply: (IHP _ _ H1P H2P).
    apply: IHQ; last by eassumption.
    apply: allfv_term_impl H1Q. by case.
Qed.

(* extensionality principle wrt. free variables on allfv_term *)
Lemma ext_allfv_allfv_term {p1 p2 P} : 
  (allfv_term (fun x => p1 x <-> p2 x) P) -> (allfv_term p1 P <-> allfv_term p2 P).
Proof. 
  move=> H. constructor.
  - apply: allfv_allfv_term_impl. apply: allfv_allfv_term_impl H.
    apply: allfv_term_triv. by move=> ? H /H.
  - apply: allfv_allfv_term_impl. apply: allfv_allfv_term_impl H.
    apply: allfv_term_triv. by move=> ? H /H.
Qed.

(* TODO could be generated by autosubst *)
(* allfv ren interaction  *)
Lemma allfv_ren_term {p xi P} : 
  allfv_term p (ren_term xi P) <-> allfv_term (fun x => p (xi x)) P .
Proof.
  elim: P p xi.
  - done.
  - done.
  - move=> P IHP Q IHQ p xi /=. by rewrite IHP IHQ.
  - move=> P IHP Q IHQ p xi /=. rewrite IHP IHQ.
    set H1Q := (allfv_term _ Q). set H2Q := (allfv_term _ Q).
    suff : H1Q <-> H2Q by move=> ->.
    subst H1Q H2Q. apply: ext_allfv_term. by case.
  - move=> P IHP Q IHQ p xi /=. rewrite IHP IHQ.
    set H1Q := (allfv_term _ Q). set H2Q := (allfv_term _ Q).
    suff : H1Q <-> H2Q by move=> ->.
    subst H1Q H2Q. apply: ext_allfv_term. by case.
Qed.

(* TODO could be generated by autosubst *)
(* allfv subst interaction  *)
Lemma allfv_subst_term {p sigma P} : 
  allfv_term p (subst_term sigma P) <-> (allfv_term (funcomp (allfv_term p) sigma) P).
Proof.
  elim: P p sigma.
  - done.
  - done.
  - move=> P IHP Q IHQ p sigma /=. by rewrite IHP IHQ.
  - move=> P IHP Q IHQ p sigma /=. rewrite IHP IHQ.
    set H1Q := (allfv_term _ Q). set H2Q := (allfv_term _ Q).
    suff : H1Q <-> H2Q by move=> ->.
    subst H1Q H2Q. apply: ext_allfv_term.
    case; first done.
    move=> ? /=. by rewrite allfv_ren_term.
  - move=> P IHP Q IHQ p sigma /=. rewrite IHP IHQ.
    set H1Q := (allfv_term _ Q). set H2Q := (allfv_term _ Q).
    suff : H1Q <-> H2Q by move=> ->.
    subst H1Q H2Q. apply: ext_allfv_term.
    case; first done.
    move=> ? /=. by rewrite allfv_ren_term.
Qed.

(* TODO could be generated by autosubst *)
(* extensionality of ren_term wrt. free variables *)
Lemma ext_allfv_ren_term {xi zeta P} : 
  allfv_term (fun x => xi x = zeta x) P -> 
  ren_term xi P = ren_term zeta P.
Proof.
  elim: P xi zeta.
  - by move=> > /= ->.
  - done.
  - by move=> P IHP Q IHQ ? ? /= [/IHP -> /IHQ ->].
  - move=> P IHP Q IHQ ? ? /= [/IHP -> HQ]. congr lam.
    apply: IHQ. apply: allfv_term_impl HQ. 
    case; [done | by move=> ? /= ->].
  - move=> P IHP Q IHQ ? ? /= [/IHP -> HQ]. congr Pi.
    apply: IHQ. apply: allfv_term_impl HQ. 
    case; [done | by move=> ? /= ->].
Qed.

(* TODO could be generated by autosubst *)
(* extensionality of subst_term wrt. allfv *)
Lemma ext_allfv_subst_term {sigma tau P} : 
  allfv_term (fun x => sigma x = tau x) P -> 
  subst_term sigma P = subst_term tau P.
Proof.
  elim: P sigma tau.
  - done.
  - done.
  - by move=> P IHP Q IHQ ? ? /= [/IHP -> /IHQ ->].
  - move=> P IHP Q IHQ ? ? /= [/IHP -> HQ]. congr lam.
    apply: IHQ. apply: allfv_term_impl HQ. 
    case; [done | by move=> ? /= ->].
  - move=> P IHP Q IHQ ? ? /= [/IHP -> HQ]. congr Pi.
    apply: IHQ. apply: allfv_term_impl HQ. 
    case; [done | by move=> ? /= ->].
Qed.

(* TODO part of autosubst? *)
(* all free variables are left unchanged by a renaming *)
Lemma ren_term_allfv_id {xi P} : 
  allfv_term (fun x => xi x = x) P -> 
  ren_term xi P = P.
Proof.
  move=> H. rewrite -[RHS]ren_term_id.
  by apply: ext_allfv_ren_term.
Qed.

(* all free variables are left unchanged by a substitution *)
Lemma subst_term_allfv_var {sigma P} : 
  allfv_term (fun x => sigma x = var x) P -> 
  subst_term sigma P = P.
Proof.
  move=> H. rewrite -[RHS]subst_term_var.
  by apply: ext_allfv_subst_term.
Qed.
