(* 
  Autor(s):
    Andrej Dudenhefner (1) 
  Affiliation(s):
    (1) Saarland University, Saarbrücken, Germany
*)

(* 
  Problem(s):
    Higher-order Semi-unification (HOSemiU)
*)

Require Import List Relation_Operators.

Require Import Undecidability.SemiUnification.pts.

(* 
  terms (according to pure type systems) 
  P Q R ::= x | c | P Q| lambda x : P. Q | Pi x : P. Q 
  where x ranges over term variables and c ranges over term constants
*)

(* single step beta reduction relation *)
Inductive step : term -> term -> Prop :=
  | step_beta P Q R: step (app (lam P Q) R) (subst_term (scons R var) Q) 
  | step_appL P P' Q: step P P' -> step (app P Q) (app P' Q)
  | step_appR P Q Q': step Q Q' -> step (app P Q) (app P Q')
  | step_lamL P P' Q: step P P' -> step (lam P Q) (app P' Q)
  | step_lamR P Q Q': step Q Q' -> step (lam P Q) (app P Q')
  | step_piL P P' Q: step P P' -> step (pi P Q) (pi P' Q)
  | step_piR P Q Q': step Q Q' -> step (pi P Q) (pi P Q').

(* a term is in normal form if it is not reducible *)
Definition normal_form (P : term) : Prop :=
  forall Q, not (step P Q).

(* beta-equality is the reflexive, symmetric, transitive closure 
  of the single step beta reduction *)
Definition eq_beta := clos_refl_sym_trans term step.

Local Notation "P =β Q" := (eq_beta P Q) (at level 50).

(* a normal valuation assigns formal forms to term variables *)
Definition normal_valuation : Type := nat -> { P : term | normal_form P }.

(* substitution function "subst_term" is defined in pts.v *)

(* replace free variables by assigned normal forms *)
Definition substitute (φ : normal_valuation) (P : term) : term :=
  subst_term (fun x => proj1_sig (φ x)) P.

(* Higher-order Semi-unification Definition *)

(* inequality: s ≤ t *)
Definition inequality : Type := (term * term).

(* φ solves s ≤ t, if there is ψ such that ψ (φ (s)) =(beta) φ (s) *)
Definition solution (φ : normal_valuation) : inequality -> Prop := 
  fun '(s, t) => exists (ψ : normal_valuation), 
    substitute ψ (substitute φ s) =β substitute φ t.

(* Semi-unification *)
(* is there a subnormal valuation φ that solves all inequalities? *)
Definition SemiU (p: list inequality) := 
  exists (φ: normal_valuation), forall (c: inequality), In c p -> solution φ c.


(* FACTS *)

Require Import ssreflect ssrbool ssrfun.

(* evaluates propositional predicate p on all free variables *)
Fixpoint allfv_term (p: nat -> Prop) (P: term) :=
  match P with
  | var x => p x
  | const _ => True 
  | app P Q => allfv_term p P /\ allfv_term p Q
  | lam P Q => allfv_term p P /\ allfv_term (scons True p) Q
  | pi P Q => allfv_term p P /\ allfv_term (scons True p) Q
  end.

(* notion of a simple type represented by a term
  s, t ::= x | Pi x : s. t (where x is not free in t)
*)
Fixpoint simple (P: term) :=
  match P with
  | var _ => True
  | const _ => False 
  | app P Q => False
  | lam P Q => False
  | pi P Q => 
      simple P /\ simple Q /\ 
      allfv_term (fun y => 0 <> y) Q
  end.

Axiom encode_term : term -> nat.
Axiom decode_term : nat -> term.
Axiom encode_decode_term : forall P, decode_term (encode_term P) = P.

(* x does not occur in t *)
Definition fresh_in (x: nat) (P: term) := allfv_term (fun y => x <> y) P.

Fixpoint fresh_inb (x: nat) (P: term) := 
  match P with
  | var y => if PeanoNat.Nat.eq_dec x y then false else true
  | const _ => true 
  | app P Q => fresh_inb x P && fresh_inb x Q
  | lam P Q => fresh_inb x P && fresh_inb (S x) Q
  | pi P Q => fresh_inb x P && fresh_inb (S x) Q
  end.

(* remember non-simple subterms as distrinct variables *)
Fixpoint prune (P: term) :=
  match P with
  | pi P' Q' => 
    if fresh_inb 0 Q' then pi (prune P') (ren_term S (prune Q')) else var (encode_term P)
  | _ => var (encode_term P)
  end.

(* could be generated by autosubst *)
(* allfv on trivial predicate *)
Lemma allfv_term_triv {p: nat -> Prop} {P}: 
  (forall x, p x) -> allfv_term p P.
Proof.
  elim: P p.
  - move=> >. by apply.
  - done.
  - move=> P IHP Q IHQ p ? /=. 
    constructor; [by apply: IHP | by apply: IHQ].
  - move=> P IHP Q IHQ p ? /=. constructor; [by apply: IHP |].
    apply: IHQ. by case.
  - move=> P IHP Q IHQ p ? /=. constructor; [by apply: IHP |].
    apply: IHQ. by case.
Qed.

(* could be generated by autosubst *)
(* allfv monotonicity *)
Lemma allfv_term_impl {p1 p2: nat -> Prop} {P}: 
  (forall x, p1 x -> p2 x) -> allfv_term p1 P -> allfv_term p2 P.
Proof.
  elim: P p1 p2.
  - move=> >. by apply.
  - done.
  - by move=> P IHP Q IHQ p1 p2 H /= [/(IHP _ _ H) ? /(IHQ _ _ H) ?].
  - move=> P IHP Q IHQ p1 p2 H /= [/IHP {}IHP /IHQ {}IHQ].
    constructor; first by apply: IHP.
    apply: IHQ. by case.
  - move=> P IHP Q IHQ p1 p2 H /= [/IHP {}IHP /IHQ {}IHQ].
    constructor; first by apply: IHP.
    apply: IHQ. by case.
Qed.

(* TODO could be generated by autosubst *)
(* extensionality principle on allfv_term *)
Lemma ext_allfv_term {p1 p2 P}: (forall x, p1 x <-> p2 x) -> allfv_term p1 P <-> allfv_term p2 P.
Proof. move=> H. by constructor; apply: allfv_term_impl; move=> ? /H. Qed.

(* TODO could be generated by autosubst *)
(* allfv ren interaction  *)
Lemma allfv_ren_term {p xi P} : allfv_term (fun x => p (xi x)) P <-> allfv_term p (ren_term xi P).
Proof.
  elim: P p xi.
  - done.
  - done.
  - move=> P IHP Q IHQ p xi /=. by rewrite -IHP -IHQ.
  - move=> P IHP Q IHQ p xi /=. rewrite -IHP -IHQ.
    set H1Q := (allfv_term _ Q). set H2Q := (allfv_term _ Q).
    suff : H1Q <-> H2Q by move=> ->.
    subst H1Q H2Q. apply: ext_allfv_term. by case.
  - move=> P IHP Q IHQ p xi /=. rewrite -IHP -IHQ.
    set H1Q := (allfv_term _ Q). set H2Q := (allfv_term _ Q).
    suff : H1Q <-> H2Q by move=> ->.
    subst H1Q H2Q. apply: ext_allfv_term. by case.
Qed.

(* renamings transport simple *)
Lemma simple_ren_term {xi P} : simple P -> simple (ren_term xi P).
Proof.
  elim: P xi => //=.
  move=> P IHP Q IHQ xi [HP] [H1Q H2Q].
  constructor; first by apply: IHP.
  constructor; first by apply: IHQ.
  apply /allfv_ren_term. apply: allfv_term_impl H2Q.
  by case.
Qed.

(* prune establishes simple *)
Lemma prune_simple P : simple (prune P).
Proof.
  elim: P => //=.
  move=> P IHP Q IHQ.
  case HQ: (fresh_inb 0 Q); last done.
  constructor; [done | constructor].
  - by apply: simple_ren_term.
  - apply /allfv_ren_term. 
    (* NOTE: assumption "fresh_inb 0 Q = true" was not used *)
    by apply: allfv_term_triv.
Qed.

Lemma normal_formE {P} : normal_form P ->
  match P with
  | var _ => True
  | const _ => True 
  | app (lam _ _) _ => False
  | app P Q => normal_form P /\ normal_form Q
  | lam P Q => normal_form P /\ normal_form Q
  | pi P Q => normal_form P /\ normal_form Q
  end.
Proof.
Admitted.

(* chained substitution equals to a normal form entails normalization on relevant substituted range *)
Lemma key1 {φ ψ P Q} : simple P -> normal_form Q -> substitute ψ (substitute φ P) =β Q -> 
  { fN : nat -> term | 
    allfv_term (fun x => normal_form (fN x) /\ substitute ψ (substitute φ (var x)) =β fN x) P}.
Proof.
  elim: P φ ψ Q => //=.
  - move=> ? ? ? Q *. by exists (fun _ => Q).
  - move=> P1 IHP1 P2 IHP2 φ ψ. case.
    + admit. (* contradiction by pi = var*)
    + admit. (* contradiction by pi = const*)
    + admit. (* contradiction by pi = app *)
    + admit.  (* contradiction by pi = lam *)
    + move=> Q1 Q2 [HP1] [HP2] H2P2 /normal_formE.
      move=> [H2Q1 H2Q2] ?.
      have HP1Q1 : substitute ψ (substitute φ (P1)) =β Q1 by admit.
      (*
      upped substitutions, needs scons
      have HP2Q2 : substitute ψ (substitute φ (P2)) =β Q2 by admit.
*)
      have [f1N Hf1N] := IHP1 Q1 HP1 H2Q1 HP1Q1.


    (*
normal form formulations

Lemma normal_formE {P} : normal_form P ->
  match P with
  | var _ => True
  | const _ => True 
  | app (lam _ _) _ => False
  | app P Q => normal_form P /\ normal_form Q
  | lam P Q => normal_form P /\ normal_form Q
  | pi P Q => normal_form P /\ normal_form Q
  end.
Proof.
  elim: P.
  - done.
  - done.
  - case.
    + move=> x _ Q. 

  move HR: (P) => R.
  elim: P R HR.
  - by move=> x R <-.
  -


  move=> Q. case.

(* a term is in normal form if it contains no beta-redex (lambda x : P. Q) R *)
Fixpoint is_normal_form (P : term) : bool :=
  match P with
  | var _ => true
  | const _ => true
  | app (lam _ _) _ => false
  | app P Q => is_normal_form P && is_normal_form Q
  | lam P Q => is_normal_form P && is_normal_form Q
  | pi P Q => is_normal_form P && is_normal_form Q
  end.



Lemma is_normal_formP {P} : reflect (normal_form P) (is_normal_form P).
Proof.
  elim: P => /=.
  - move=> x. constructor=> Q. move HP: (var x) => P HPQ.
    by case: HPQ HP.
  - move=> c. constructor=> Q. move HP: (const c) => P HPQ.
    by case: HPQ HP.
  - case => /=.
    + move=> x _ Q HQ. move HP: (app _ _) => P.
      apply : (iffP HQ).
    Search reflect.
    
    constructor.
*)