(* 
  Autor(s):
    Andrej Dudenhefner (1) 
  Affiliation(s):
    (1) Saarland University, Saarbrücken, Germany
*)

(* 
  Problem(s):
    Higher-order Semi-unification (HOSemiU)
*)

Require Import List Relation_Operators.

Require Import Undecidability.SemiUnification.pts.

(* 
  terms (according to pure type systems) 
  P Q R ::= x | c | P Q| lambda x : P. Q | Pi x : P. Q 
  where x ranges over term variables and c ranges over term constants
*)

(* single step beta reduction relation *)
Inductive step : term -> term -> Prop :=
  | step_beta P Q R: step (app (lam P Q) R) (subst_term (scons R var) Q) 
  | step_appL P P' Q: step P P' -> step (app P Q) (app P' Q)
  | step_appR P Q Q': step Q Q' -> step (app P Q) (app P Q')
  | step_lamL P P' Q: step P P' -> step (lam P Q) (app P' Q)
  | step_lamR P Q Q': step Q Q' -> step (lam P Q) (app P Q')
  | step_piL P P' Q: step P P' -> step (pi P Q) (pi P' Q)
  | step_piR P Q Q': step Q Q' -> step (pi P Q) (pi P Q').

(* a term is in normal form if it is not reducible *)
Definition normal_form (P : term) : Prop :=
  forall Q, not (step P Q).

(* beta-equality is the reflexive, symmetric, transitive closure 
  of the single step beta reduction *)
Definition eq_beta := clos_refl_sym_trans term step.

Local Notation "P =β Q" := (eq_beta P Q) (at level 50).

(* a normal valuation assigns formal forms to term variables *)
Definition normal_valuation : Type := nat -> { P : term | normal_form P }.

(* substitution function "subst_term" is defined in pts.v *)

(* replace free variables by assigned normal forms *)
Definition substitute (φ : normal_valuation) (P : term) : term :=
  subst_term (fun x => proj1_sig (φ x)) P.

(* Higher-order Semi-unification Definition *)

(* inequality: s ≤ t *)
Definition inequality : Type := (term * term).

(* φ solves s ≤ t, if there is ψ such that ψ (φ (s)) =(beta) φ (s) *)
Definition solution (φ : normal_valuation) : inequality -> Prop := 
  fun '(s, t) => exists (ψ : normal_valuation), 
    substitute ψ (substitute φ s) =β substitute φ t.

(* Higher-order Semi-unification *)
(* is there a subnormal valuation φ that solves all inequalities? *)
Definition HOSemiU (p: list inequality) := 
  exists (φ: normal_valuation), forall (c: inequality), In c p -> solution φ c.







(* FACTS *)
Require Import PeanoNat Lia.
Require Import ssreflect ssrbool ssrfun.


Definition term_norm := (compRen_term, renRen_term, rinstId_term, renComp_term).

(* such that simpl evaluates funcomp f g x *)
Arguments funcomp {X Y Z} _ _ _ /.
(* such that simpl evaluates id x*)
Arguments unscoped.id _ _/.

(* evaluates propositional predicate p on all free variables *)
Fixpoint allfv_term (p: nat -> Prop) (P: term) :=
  match P with
  | var x => p x
  | const _ => True 
  | app P Q => allfv_term p P /\ allfv_term p Q
  | lam P Q => allfv_term p P /\ allfv_term (scons True p) Q
  | pi P Q => allfv_term p P /\ allfv_term (scons True p) Q
  end.

(* notion of a simple type represented by a term
  s, t ::= x | Pi x : s. t (where x is not free in t)
*)
Fixpoint simple (P: term) :=
  match P with
  | var _ => True
  | const _ => False 
  | app P Q => False
  | lam P Q => False
  | pi P Q => 
      simple P /\ simple Q /\ 
      allfv_term (fun y => 0 <> y) Q
  end.

Axiom encode_term : term -> nat.
Axiom decode_term : nat -> term.
Axiom encode_decode_term : forall P, decode_term (encode_term P) = P.

(* x does not occur in t *)
Fixpoint fresh_inb (x: nat) (P: term) : bool := 
  match P with
  | var y => if Nat.eq_dec x y then false else true
  | const _ => true 
  | app P Q => fresh_inb x P && fresh_inb x Q
  | lam P Q => fresh_inb x P && fresh_inb (S x) Q
  | pi P Q => fresh_inb x P && fresh_inb (S x) Q
  end.

Lemma fresh_inbP {x P} : reflect (allfv_term (fun y => x <> y) P) (fresh_inb x P).
Proof.
Admitted.

(* make a term simple, remember non-simpel subterms as variables *)
Fixpoint prune (xi: nat -> nat) (P: term) : term :=
  match P with
  | pi P' Q' => 
      if fresh_inb 0 Q' 
        then pi (prune xi P') (ren_term shift (prune (scons 0 xi) Q'))
        else var (encode_term (ren_term xi P))
  | _ => var (encode_term (ren_term xi P))
  end.




(* remember non-simple subterms as distrinct variables 
wrong because de Bruijn in prune Q' shifts variable names and rename before prune is not structural
Fixpoint prune (P: term) :=
  match P with
  | pi P' Q' => 
    if fresh_inb 0 Q' 
      then pi (prune P') (ren_term S (prune Q')) 
      else var (encode_term P)
  | _ => var (encode_term P)
  end.
*)


(* TODO could be generated by autosubst *)
(* allfv on trivial predicate *)
Lemma allfv_term_triv {p: nat -> Prop} {P}: 
  (forall x, p x) -> allfv_term p P.
Proof.
  elim: P p.
  - move=> >. by apply.
  - done.
  - move=> P IHP Q IHQ p ? /=. 
    constructor; [by apply: IHP | by apply: IHQ].
  - move=> P IHP Q IHQ p ? /=. constructor; [by apply: IHP |].
    apply: IHQ. by case.
  - move=> P IHP Q IHQ p ? /=. constructor; [by apply: IHP |].
    apply: IHQ. by case.
Qed.

(* TODO could be generated by autosubst *)
(* allfv monotonicity *)
Lemma allfv_term_impl {p1 p2: nat -> Prop} {P}: 
  (forall x, p1 x -> p2 x) -> allfv_term p1 P -> allfv_term p2 P.
Proof.
  elim: P p1 p2.
  - move=> >. by apply.
  - done.
  - by move=> P IHP Q IHQ p1 p2 H /= [/(IHP _ _ H) ? /(IHQ _ _ H) ?].
  - move=> P IHP Q IHQ p1 p2 H /= [/IHP {}IHP /IHQ {}IHQ].
    constructor; first by apply: IHP.
    apply: IHQ. by case.
  - move=> P IHP Q IHQ p1 p2 H /= [/IHP {}IHP /IHQ {}IHQ].
    constructor; first by apply: IHP.
    apply: IHQ. by case.
Qed.

(* TODO could be generated by autosubst *)
(* extensionality principle on allfv_term *)
Lemma ext_allfv_term {p1 p2 P}: (forall x, p1 x <-> p2 x) -> allfv_term p1 P <-> allfv_term p2 P.
Proof. move=> H. by constructor; apply: allfv_term_impl; move=> ? /H. Qed.

(* TODO could be generated by autosubst *)
(* allfv ren interaction  *)
Lemma allfv_ren_term {p xi P} : allfv_term p (ren_term xi P) <-> allfv_term (fun x => p (xi x)) P .
Proof.
  elim: P p xi.
  - done.
  - done.
  - move=> P IHP Q IHQ p xi /=. by rewrite IHP IHQ.
  - move=> P IHP Q IHQ p xi /=. rewrite IHP IHQ.
    set H1Q := (allfv_term _ Q). set H2Q := (allfv_term _ Q).
    suff : H1Q <-> H2Q by move=> ->.
    subst H1Q H2Q. apply: ext_allfv_term. by case.
  - move=> P IHP Q IHQ p xi /=. rewrite IHP IHQ.
    set H1Q := (allfv_term _ Q). set H2Q := (allfv_term _ Q).
    suff : H1Q <-> H2Q by move=> ->.
    subst H1Q H2Q. apply: ext_allfv_term. by case.
Qed.

(* TODO could be generated by autosubst *)
(* allfv subst interaction  *)
Lemma allfv_subst_term {p sigma P} : 
  allfv_term p (subst_term sigma P) <-> (allfv_term (funcomp (allfv_term p) sigma) P).
Proof.
  elim: P p sigma.
  - done.
  - done.
  - move=> P IHP Q IHQ p sigma /=. by rewrite IHP IHQ.
  - move=> P IHP Q IHQ p sigma /=. rewrite IHP IHQ.
    set H1Q := (allfv_term _ Q). set H2Q := (allfv_term _ Q).
    suff : H1Q <-> H2Q by move=> ->.
    subst H1Q H2Q. apply: ext_allfv_term.
    case; first done.
    move=> ? /=. by rewrite allfv_ren_term.
  - move=> P IHP Q IHQ p sigma /=. rewrite IHP IHQ.
    set H1Q := (allfv_term _ Q). set H2Q := (allfv_term _ Q).
    suff : H1Q <-> H2Q by move=> ->.
    subst H1Q H2Q. apply: ext_allfv_term.
    case; first done.
    move=> ? /=. by rewrite allfv_ren_term.
Qed.

(* TODO could be generated by autosubst *)
(* extensionality of ren_term wrt. allfv *)
Lemma ext_allfv_ren_term {xi zeta P} : allfv_term (fun x => xi x = zeta x) P -> 
  ren_term xi P = ren_term zeta P.
Proof.
  elim: P xi zeta.
  - by move=> > /= ->.
  - done.
  - by move=> P IHP Q IHQ ? ? /= [/IHP -> /IHQ ->].
  - move=> P IHP Q IHQ ? ? /= [/IHP -> HQ]. congr lam.
    apply: IHQ. apply: allfv_term_impl HQ. 
    case; [done | by move=> ? /= ->].
  - move=> P IHP Q IHQ ? ? /= [/IHP -> HQ]. congr pi.
    apply: IHQ. apply: allfv_term_impl HQ. 
    case; [done | by move=> ? /= ->].
Qed.

(* TODO could be generated by autosubst *)
(* extensionality of subst_term wrt. allfv *)
Lemma ext_allfv_subst_term {sigma tau P} : allfv_term (fun x => sigma x = tau x) P -> 
  subst_term sigma P = subst_term tau P.
Proof.
  elim: P sigma tau.
  - done.
  - done.
  - by move=> P IHP Q IHQ ? ? /= [/IHP -> /IHQ ->].
  - move=> P IHP Q IHQ ? ? /= [/IHP -> HQ]. congr lam.
    apply: IHQ. apply: allfv_term_impl HQ. 
    case; [done | by move=> ? /= ->].
  - move=> P IHP Q IHQ ? ? /= [/IHP -> HQ]. congr pi.
    apply: IHQ. apply: allfv_term_impl HQ. 
    case; [done | by move=> ? /= ->].
Qed.

(* renamings transport simple *)
Lemma simple_ren_term {xi P} : simple P -> simple (ren_term xi P).
Proof.
  elim: P xi => //=.
  move=> P IHP Q IHQ xi [HP] [H1Q H2Q].
  constructor; first by apply: IHP.
  constructor; first by apply: IHQ.
  apply /allfv_ren_term. apply: allfv_term_impl H2Q.
  by case.
Qed.

(* prune establishes simple *)
Lemma prune_simple xi P : simple (prune xi P).
Proof.
  elim: P xi => //=.
  move=> P IHP Q IHQ xi.
  case HQ: (fresh_inb 0 Q); last done.
  constructor; [done | constructor].
  - by apply: simple_ren_term.
  - apply /allfv_ren_term. 
    (* NOTE: assumption "fresh_inb 0 Q = true" was not used *)
    by apply: allfv_term_triv.
Qed.

(* extensionality principle for prune wrt. allfv *)
Lemma ext_allfv_prune_term {zeta xi P} : 
  allfv_term (fun x => xi x = zeta x) P -> prune xi P = prune zeta P.
Proof.
Admitted.

Lemma normal_formE {P} : normal_form P ->
  match P with
  | var _ => True
  | const _ => True 
  | app (lam _ _) _ => False
  | app P Q => normal_form P /\ normal_form Q
  | lam P Q => normal_form P /\ normal_form Q
  | pi P Q => normal_form P /\ normal_form Q
  end.
Proof.
Admitted.

Lemma prune_ren_term {xi zeta P} : prune xi (ren_term zeta P) = prune (funcomp xi zeta) P.
Proof.
  elim: P xi zeta.
  - done.
  - done.
  - move=> * /=. by rewrite ?term_norm.
  - move=> P IHP Q IHQ ? ? /=. congr (var (encode_term (lam _ _))).
    + by rewrite ?term_norm.
    + rewrite term_norm. apply: extRen_term. by case.
  - move=> P IHP Q IHQ ? ? /=.
    case H1Q: (fresh_inb _ Q); case H'1Q: (fresh_inb _ _).
    + congr pi; first done.
      congr ren_term. rewrite IHQ. apply: ext_allfv_prune_term.
      apply: allfv_term_triv. by case.
    + exfalso. move: H'1Q => /fresh_inbP. apply.
      apply /allfv_ren_term. move: H1Q => /fresh_inbP.
      apply: allfv_term_impl. by case.
    + exfalso. move: H1Q => /fresh_inbP. apply.
      move: H'1Q => /fresh_inbP /allfv_ren_term.
      apply: allfv_term_impl. by case.
    + congr (var (encode_term (pi _ _))); first by rewrite ?term_norm.
      rewrite term_norm. apply: extRen_term. by case.
Qed.


(* pruning an instance of a simple type can be internalized *)
(* "KEY LEMMA 1" *)
Lemma prune_subst_term {xi sigma P} : simple P -> prune xi (subst_term sigma P) = subst_term (funcomp (prune xi) sigma) P.
Proof.
  elim: P xi sigma => //=.
  move=> P IHP Q IHQ xi sigma.
  move=> [HP] [H1Q H2Q]. case H3Q: (fresh_inb _ _).
  - congr pi; first by apply: IHP.
    rewrite (IHQ _ _ H1Q) term_norm.
    (* ext_term not applicable because substitutions are different on 0, which is absent *)
    apply: ext_allfv_subst_term.
    apply: allfv_term_impl H2Q.
    case; first done.
    move=> x _ /=. congr ren_term. by rewrite prune_ren_term.
  - exfalso. move: H3Q => /fresh_inbP. apply.
    rewrite allfv_subst_term. apply: allfv_term_impl H2Q.
    move=> [|? _] /=; first done.
    apply /allfv_ren_term. by apply: allfv_term_triv.
Qed.

(* TODO part of autosubst? *)
Lemma upRen_term_term_id x : upRen_term_term id x = x.
Proof. by case: x. Qed.

(* TODO autosubst? *)
Lemma shift_up_term_term sigma x : (shift >> up_term_term sigma) x = (sigma >> ren_term shift) x.
Proof. by case: x. Qed.

(* TODO autosubst? *)
Lemma ext_ren_term' {xi zeta P Q} : 
  (forall x, xi x = zeta x) -> P = Q -> ren_term xi P = ren_term zeta Q.
Proof. by move=> /extRen_term + ->. Qed.


(* TODO autosubst? sometimes more easy to use *)
Lemma up_ren_subst_term_term' xi sigma x:
  (upRen_term_term xi >> up_term_term sigma) x = up_term_term (xi >> sigma) x.
Proof. by apply: up_ren_subst_term_term. Qed.

(* x is fresh in P iff x renamed to any z does not change P *)
Lemma fresh_inbP' x P : fresh_inb x P = true <-> 
  (forall z, ren_term (Nat.iter x upRen_term_term (scons z shift)) P = P).
Proof.
  rewrite -/(is_true _) -(rwP fresh_inbP). elim: P x.
  - move=> y x /=. admit.
  - done.
  - admit.
  - move=> P IHP Q IHQ x /=. constructor.
    + move=> [HP HQ] z. congr lam.
      * by apply /(iffLR (IHP x)).
      * have -> := iffLR (IHQ (S x)) _ z; last done.
        apply: allfv_term_impl HQ.
        case; first done.
        move=> ? /=. by lia.
    + move=> H. constructor.
      * apply /(iffRL (IHP x)) => z.
        by case: (H z).
      * have := iffRL (IHQ (S x)). admit. (* easy *)
Admitted.

(* x is fresh in P iff there is room to shift variable names to/from x *)
Lemma fresh_inbP'' x P : fresh_inb x P = true <-> 
  (P = ren_term (Nat.iter x upRen_term_term shift) 
        (ren_term (Nat.iter x upRen_term_term (scons 0 id)) P)).
Proof.
  elim: P x.
  - move=> y x /=. constructor.
    + case: (Nat.eq_dec x y); first done.
      move=> /= Hxy _. congr var.
      elim: x y Hxy; first by case.
      move=> x IH [|y]; first done.
      move=> ? /=. congr S. apply: IH. by lia.
    + case: (Nat.eq_dec x y); last done.
      move=> /= <- []. elim: x; first done.
      by move=> x IH /= [].
  - done.
  - move=> P IHP Q IHQ x /=. constructor.
    + by move=> /andP => - [/IHP <-] /IHQ <-.
    + by move=> [/IHP -> /IHQ ->].
  - move=> P IHP Q IHQ x /=. constructor.
    + by move=> /andP => - [/IHP <-] /IHQ <-.
    + by move=> [/IHP -> /(IHQ (S x)) ->].
  - move=> P IHP Q IHQ x /=. constructor.
    + by move=> /andP => - [/IHP <-] /IHQ <-.
    + by move=> [/IHP -> /(IHQ (S x)) ->].
Qed.

(* 0 is fresh in P if P is some shifted term Q *)
Corollary fresh_inb0P'' P : fresh_inb 0 P = true <-> 
  (exists Q, P = ren_term shift Q).
Proof.
  rewrite fresh_inbP'' /=. constructor.
  - move=> ->. by eexists.
  - move=> [Q] ->.  rewrite ?term_norm.
    apply: extRen_term. by case.
Qed.

Lemma fN_fresh_inbI (fN : term -> term) {P} :
  (forall P', fN (ren_term shift P') = ren_term shift (fN P')) ->
  fresh_inb 0 P = true -> fresh_inb 0 (fN P) = true.
Proof.
  move=> HfN /fresh_inb0P'' => - [Q ->].
  apply /fresh_inb0P''. exists (fN Q).
  by rewrite HfN.
Qed.

Lemma up_term_term_funcomp {xi sigma x} : 
  up_term_term (xi >> sigma) x = (upRen_term_term xi >> up_term_term sigma) x.
Proof.
  by case: x.
Qed.

(* pruning intanciated pruned instance (?) *)
(* "KEY LEMMA 2", tau is the resulting simple substitution *)
(* NOTE: fN is the relevant normalizer, xi3 = xi1 = id *)
Lemma key2 {fN : term -> term} {sigma xi1 xi3 P} : 
  (* fN preserves pi *)
  (forall P' Q', fN (pi P' Q') = pi (fN P') (fN Q')) ->
  (* fN preserves shifts; strong assumption *)
  (forall P', fN (ren_term shift P') = ren_term shift (fN P')) ->
  (* resulting simple valuation *)
  let tau := (fun x => ren_term xi3 (prune id (fN (subst_term sigma (decode_term x))))) in
  (* homomorphism *)
  subst_term tau (prune xi1 P) = ren_term xi3 (prune id (fN (subst_term (funcomp sigma xi1) P))).
Proof.
  move=> H1fN H2fN tau. subst tau.
  elim: P xi1 xi3 sigma.
  - move=> > /=. by rewrite encode_decode_term.
  - move=> > /=. by rewrite encode_decode_term.
  - move=> * /=. by rewrite encode_decode_term /= ?term_norm.
  - move=> P IHP Q IHQ xi1 xi3 sigma /=. rewrite encode_decode_term /= ?term_norm /=.
    congr (ren_term xi3 (prune id (fN (lam _ _)))). apply: ext_term. by case.
    (* case pi P Q *)
  - move=> P IHP Q IHQ xi1 xi3 sigma /=.
    case HQ: (fresh_inb 0 Q).
    (* case (var 0) does not occur in Q *)
    + rewrite H1fN /=.

    have -> : fresh_inb 0 (fN (subst_term (up_term_term (funcomp sigma xi1)) Q)) = true.
    { apply: fN_fresh_inbI; first done.
      apply /fresh_inbP. move: HQ => /fresh_inbP.
      rewrite allfv_subst_term. apply: allfv_term_impl.
      move=> [|? _ /=]; [done | ]. rewrite allfv_ren_term.
      by apply: allfv_term_triv. }
      move=> /=. congr pi; first done.
      rewrite term_norm.
      under [subst_term _ (prune _ Q)]ext_term => ? do 
        rewrite shift_up_term_term /funcomp term_norm.
      rewrite IHQ term_norm. apply: ext_ren_term'; first by case.

      have ->: subst_term (up_term_term (xi1 >> sigma)) Q = 
        ren_term shift (subst_term ((0 .: xi1) >> sigma) Q).
      { rewrite term_norm. apply: ext_allfv_subst_term.
        move: HQ => /fresh_inbP. apply: allfv_term_impl. by case. }
      by rewrite H2fN prune_ren_term.
    (* case (var 0) occurs in Q *)
    + rewrite /= encode_decode_term /= ?term_norm.
      under [subst_term (up_term_term _) _]ext_term => ?
        do rewrite -up_ren_subst_term_term'.
      done.
Qed.

Fixpoint simple_map_term (f: term -> term) (P: term) : term :=
  match P with
  | pi P' Q' => 
      if fresh_inb 0 Q' 
        then pi (simple_map_term f P') 
          (ren_term shift (simple_map_term ((ren_term (scons 0 id)) >> f) Q'))
        else f P
  | _ => f P
  end.

Lemma simple_map_ren_term {f xi P} : 
  simple_map_term f (ren_term xi P)  = simple_map_term (ren_term xi >> f) P.
Proof.
  elim: P f xi.
  - done.
Admitted.

(* pruning intanciated pruned instance (?) *)
(* "KEY LEMMA 2", tau is the resulting simple substitution *)
(* NOTE: fN is the relevant normalizer, xi3 = xi1 = id *)
(* ALTERNATIVE FORMULATION WITH "simple_map" *)
Lemma key2' {fN : term -> term} {sigma xi1 xi3 P} : 
  (* resulting simple valuation *)
  let tau := (fun x => ren_term xi3 (prune id (simple_map_term fN (subst_term sigma (decode_term x))))) in
  (* homomorphism *)
  subst_term tau (prune xi1 P) = ren_term xi3 (prune id (simple_map_term fN (subst_term (funcomp sigma xi1) P))).
Proof.
  move=> tau. subst tau.
  elim: P xi1 xi3 sigma.
  - move=> > /=. by rewrite encode_decode_term.
  - move=> > /=. by rewrite encode_decode_term.
  - move=> * /=. by rewrite encode_decode_term /= ?term_norm.
  - move=> P IHP Q IHQ xi1 xi3 sigma /=. rewrite encode_decode_term /= ?term_norm /=.
    congr (ren_term xi3 (prune id (simple_map_term fN (lam _ _)))). apply: ext_term. by case.
    (* case pi P Q *)
  - move=> P IHP Q IHQ xi1 xi3 sigma /=.
    case HQ: (fresh_inb 0 Q).
    (* case (var 0) does not occur in Q *)
    + have -> : fresh_inb 0 (subst_term (up_term_term (xi1 >> sigma)) Q) = true.
      { apply /fresh_inbP. move: HQ => /fresh_inbP.
        rewrite allfv_subst_term. apply: allfv_term_impl.
        move=> [|x _ /=]; first done.
        rewrite allfv_ren_term. apply: allfv_term_triv. by case. }
      move=> /=.
      set b := (fresh_inb 0 _). have ->: b = true.
      { subst b. apply /fresh_inbP. rewrite allfv_ren_term. 
        apply: allfv_term_triv. by case. }
      move=> /=. congr pi; first done.
      rewrite ?term_norm. rewrite prune_ren_term.
      have -> : (↑ >> (0 .: id)) = id by done.
      under [subst_term _ (prune _ Q)]ext_term => ? do 
        rewrite shift_up_term_term /funcomp term_norm.
      rewrite IHQ. apply: ext_ren_term'; first by case.
      rewrite -simple_map_ren_term term_norm. congr (prune id (simple_map_term fN _)). 
      apply: ext_allfv_subst_term. move: HQ => /fresh_inbP.
      apply: allfv_term_impl => - [|? _ /=]; first done.
      by rewrite ?term_norm.
    (* case (var 0) occurs in Q *)
    + rewrite /= encode_decode_term /= ?term_norm.
      under [subst_term (up_term_term _) _]ext_term => ?
        do rewrite -up_ren_subst_term_term'.
      done.
Qed.

(* pruning intanciated pruned instance (?) *)
(* "KEY LEMMA 2", tau is the resulting simple substitution *)
(* NOTE: fN is the relevant normalizer *)
(* ALTERNATIVE FORMULATION WITH "simple_map" *)
Corollary key2'_final {fN : term -> term} {sigma P} : 
  (* resulting simple valuation *)
  let tau := (fun x => prune id (simple_map_term fN (subst_term sigma (decode_term x)))) in
  (* homomorphism *)
  subst_term tau (prune id P) = prune id (simple_map_term fN (subst_term sigma P)).
Proof. have := @key2' fN sigma id id P. by rewrite /= term_norm. Qed.

Definition red_beta := clos_refl_trans term step.

Lemma term_eq_dec (P Q: term) : {P = Q} + {P <> Q}.
Proof. by do 2 (decide equality). Qed. 

Lemma ext_simple_map_term {f g P} : (forall P', f P' = g P') -> 
  simple_map_term f P = simple_map_term g P.
Proof.
  elim: P f g.
  - move=> >. by apply.
  - move=> >. by apply.
  - move=> P IHP Q IHQ f g. by apply.
  - move=> P IHP Q IHQ f g. by apply.
  - move=> P IHP Q IHQ f g Hfg /=. 
    case HQ: (fresh_inb 0 Q); last done.
    congr pi; first by apply IHP.
    congr ren_term. apply: IHQ. by move=> P' /=.
Qed.

Lemma simple_map_term_id {P} : 
  simple_map_term id P = P.
Proof.
  elim: P => //.
  move=> P IHP Q IHQ /=. case HQ: (fresh_inb 0 Q); last done.
  congr pi; first done.
Admitted.

Lemma simple_map_simple_map_term {f g P} :
  simple_map_term g (simple_map_term f P) = simple_map_term (f >> simple_map_term g) P.
Proof.
  elim: P f g => //.
  move=> P IHP Q IHQ f g /=. case HQ: (fresh_inb 0 Q); last done.
  rewrite /=. set b := (fresh_inb 0 _).
  have ->: b = true.
  { subst b. apply /fresh_inbP. rewrite allfv_ren_term.
    apply: allfv_term_triv. by case. }
  congr pi; first done.
  congr ren_term. rewrite simple_map_ren_term IHQ.
  apply: ext_simple_map_term => ? /=.
  apply: ext_simple_map_term => ? /=.
  by rewrite ?term_norm.
Qed.

Lemma red_beta_piI {P Q P' Q'} : 
  red_beta P P' -> red_beta Q Q' -> red_beta (pi P Q) (pi P' Q').
Proof.
Admitted.

Lemma red_beta_diamond {P Q1 Q2} : red_beta P Q1 -> red_beta P Q2 -> 
  { Q | red_beta Q1 Q /\ red_beta Q2 Q }.
Proof.
Admitted.

Lemma simple_map_term_red_beta_impl {f g P} : (forall P', red_beta (f P') (g P')) ->
  red_beta (simple_map_term f P) (simple_map_term g P).
Proof.
Admitted.

Lemma ren_simple_map_term {xi f P} : 
  ren_term xi (simple_map_term f P) = simple_map_term (f >> ren_term xi) P.
Proof.
  elim: P xi f => //.
  move=> P IHP Q IHQ xi f /=.
  case HQ: (fresh_inb 0 Q); last done.
  move=> /=. congr pi; first done.
  rewrite term_norm ?IHQ. apply: ext_simple_map_term => ?.
  rewrite /= term_norm. apply: extRen_term.
  by case.
Qed.

Lemma red_beta_ren_termI xi {P Q} : red_beta P Q -> red_beta (ren_term xi P) (ren_term xi Q).
Proof.
Admitted.

Lemma red_beta_allfv_termI {p P Q} : red_beta P Q -> allfv_term p P -> allfv_term p Q.
Proof.
Admitted.

(* pruning intanciated pruned instance (?) *)
(* "KEY LEMMA 3", fN is the relevant normalizer *)
(* to use with "key2'_final" *)
Lemma construct_fN xi P Q : red_beta P Q -> 
  exists (fN : term -> term), 
    red_beta (ren_term xi Q) (simple_map_term fN (ren_term xi P)) /\
    (forall R, red_beta R (fN R)).
Proof.
  elim: P xi Q.
  - move=> x xi Q HQ. exists id. rewrite simple_map_term_id. constructor.
    + apply: red_beta_ren_termI. admit. (* easy by NF *)
    + move=> ?. by apply: rt_refl.
  - move=> c xi Q HQ. exists id. rewrite simple_map_term_id. constructor.
    + apply: red_beta_ren_termI. admit. (* easy by NF *)
    + move=> ?. by apply: rt_refl.
  - move=> P IHP Q IHQ xi R HR.
    exists (fun R' => if term_eq_dec R' (ren_term xi (app P Q)) then (ren_term xi R) else R').
    constructor.
    + move=> /=. case: (term_eq_dec _ _) => /=; last done.
      move=> _. by apply: rt_refl.
    + move=> ?. case: (term_eq_dec _ _).
      * move=> /= ->. rewrite -/(ren_term xi (app _ _)).
        by apply: red_beta_ren_termI.
      * move=> /= _. by apply: rt_refl.
    - move=> P IHP Q IHQ xi R HR.
      exists (fun R' => if term_eq_dec R' (ren_term xi (lam P Q)) then (ren_term xi R) else R').
      constructor.
      + move=> /=. case: (term_eq_dec _ _) => /=; last done.
        move=> _. by apply: rt_refl.
      + move=> ?. case: (term_eq_dec _ _).
        * move=> /= ->. rewrite -/(ren_term xi (lam _ _)).
          by apply: red_beta_ren_termI.
        * move=> /= _. by apply: rt_refl.
  - move=> P IHP Q IHQ xi R HR /=.
    case HQ: (fresh_inb 0 _).
    + have : exists P' Q', R = pi P' Q' /\ (red_beta P P') /\ (red_beta Q Q') by admit. (* easy by NF *)
      move=> [P'] [Q'] [->] [HPP' HQQ'].
      have [fNP [H1fNP H2fNP]] := IHP xi _ HPP'.
      have [fNQ [H1fNQ H2fNQ]] := IHQ (scons 0 xi) _ HQQ'.
      exists (fun R' => sval (red_beta_diamond (H2fNP R') (H2fNQ R'))).
      constructor.
      * rewrite /=. apply: red_beta_piI.
        ** apply: rt_trans; first by eassumption.
           apply: simple_map_term_red_beta_impl => R'.
           by move: (sval _) (svalP (red_beta_diamond (H2fNP R') (H2fNQ R'))) => ? [].
        ** have ->: ren_term (upRen_term_term xi) Q' = ren_term shift (ren_term (0 .: xi) Q').
           { rewrite term_norm. apply: ext_allfv_ren_term.
             apply: red_beta_allfv_termI; first by eassumption.
             move: HQ => /fresh_inbP. rewrite allfv_ren_term.
             apply: allfv_term_impl. by case. }
            apply: red_beta_ren_termI.

            rewrite -simple_map_ren_term term_norm.
            have HH : forall x, (upRen_term_term xi >> (0 .: id)) x = (0 .: xi) x.
            by case.
            under [ren_term _ Q]extRen_term => ? do rewrite HH.

            apply: rt_trans; first by eassumption.
            apply: simple_map_term_red_beta_impl => R'.
            by move: (sval _) (svalP (red_beta_diamond (H2fNP R') (H2fNQ R'))) => ? [].
      * move=> R'.
        move: (sval _) (svalP (red_beta_diamond (H2fNP R') (H2fNQ R'))) => R'' [? _].
        apply: rt_trans; last by eassumption.
        by apply: H2fNP.
    + exists (fun R' => if term_eq_dec R' (ren_term xi (pi P Q)) then (ren_term xi R) else R').
    constructor.
    * move=> /=. case: (term_eq_dec _ _) => /=; last done.
      move=> _. by apply: rt_refl.
    * move=> ?. case: (term_eq_dec _ _).
      ** move=> /= ->. rewrite -/(ren_term xi (pi _ _)).
        by apply: red_beta_ren_termI.
      ** move=> /= _. by apply: rt_refl.
Admitted.



(* maybe needs CPS renaming *)
(* interesting case only for single beta step*)
Lemma construct_fN P Q : red_beta P Q -> 
  exists (fN : term -> term), 
    red_beta Q (simple_map_term fN P) /\
    (forall R, red_beta R (fN R)).
Proof.
  elim: P Q.
  - move=> x Q HQ. exists id. rewrite simple_map_term_id. admit.
  - move=> c Q HQ. exists id. rewrite simple_map_term_id. admit.
  - move=> P IHP Q IHQ R HR.
    exists (fun R' => if term_eq_dec R' (app P Q) then R else R').
    constructor.
    + move=> /=. case: (term_eq_dec _ _); last done.
      move=> /= _. by apply: rt_refl.
    + move=> ?. case: (term_eq_dec _ _).
      * by move=> /= ->.
      * move=> /= _. by apply: rt_refl.
  - move=> P IHP Q IHQ R HR.
    exists (fun R' => if term_eq_dec R' (lam P Q) then R else R').
    constructor.
    + move=> /=. case: (term_eq_dec _ _); last done.
      move=> /= _. by apply: rt_refl.
    + move=> ?. case: (term_eq_dec _ _).
      * by move=> /= ->.
      * move=> /= _. by apply: rt_refl.
  - move=> P IHP Q IHQ R HR.
    case HQ: (fresh_inb 0 Q).
    + have : exists P' Q', R = pi P' Q' /\ (red_beta P P') /\ (red_beta Q Q') by admit.
      move=> [P'] [Q'] [->] [HPP' HQQ'].
      have [fNP [H1fNP H2fNP]] := IHP _ HPP'.
      have [fNQ [H1fNQ H2fNQ]] := IHQ _ HQQ'.
      exists (fun R' => sval (red_beta_diamond (H2fNP R') (H2fNQ R'))).
      constructor.
      * rewrite /= HQ. apply: red_beta_piI.
        ** apply: rt_trans; first by eassumption.
           apply: simple_map_term_red_beta_impl => R'.
           by move: (sval _) (svalP (red_beta_diamond (H2fNP R') (H2fNQ R'))) => ? [].
        ** apply: rt_trans; first by eassumption.
          have ->: Q = var 1 by admit.
          simpl. ?????????
        rewrite -simple_map_ren_term.
           rewrite ren_simple_map_term.
           rewrite -simple_map_ren_term.
  
           apply: simple_map_term_red_beta_impl => R' /=.
           move: (sval _) (svalP (red_beta_diamond (H2fNP (ren_term (0 .: id) R')) (H2fNQ (ren_term (0 .: id) R')))) => ? [].
           move=> _ /(red_beta_ren_termI shift).
           congr red_beta.
           NOOOOO simple with renaming but no fnq?
          admit.
      * move=> R'.
        move: (sval _) (svalP (red_beta_diamond (H2fNP R') (H2fNQ R'))) => R'' [? _].
        apply: rt_trans; last by eassumption.
        by apply: H2fNP.
    + exists (fun R' => if term_eq_dec R' (pi P Q) then R else R').
      constructor.
      + move=> /=. case: (term_eq_dec _ _); last done.
        move=> /= _. by apply: rt_refl.
      + move=> ?. case: (term_eq_dec _ _).
        * by move=> /= ->.
        * move=> /= _. by apply: rt_refl.


(* interesting case only for single beta step*)
Lemma construct_fN P Q : red_beta P Q -> 
  exists (fN : term -> term), red_beta Q (simple_map_term fN P).
Proof.
  elim: P Q.
  - move=> x Q ?. exists (fun=> Q). by apply: rt_refl.
  - move=> c Q ?. exists (fun=> Q). by apply: rt_refl.
  - move=> P IHP Q IHQ R.
    exists (fun=> R). by apply: rt_refl.
  - move=> P IHP Q IHQ R.
    exists (fun=> R). by apply: rt_refl.
  - move=> P IHP Q IHQ R HPQ.
    case HQ: (fresh_inb 0 Q).
    + have : exists P' Q', R = pi P' Q' /\ (red_beta P P') /\ (red_beta Q Q') by admit.
      move=> [P'] [Q'] [->] [HPP' HQQ'].
      have [fNP HfNP] := IHP _ HPP'.
      have [fNQ HfNQ] := IHQ _ HQQ'.
      exists (fun R' => if term_eq_dec P R' then P' else Q').
      rewrite /= HQ. apply: red_beta_piI => /=.
      * ??? 
    + exists (fun=> R) => /=. rewrite HQ. by apply: rt_refl.


  move HP: (P) => R.
  elim: R P Q HP.
  - move=> x P Q HP ?.
    exists (fun _ => Q).
    by apply: rt_refl.
  - admit.
  -

  elim: P Q.
  - move=> *. exists id. rewrite simple_map_term_id. admit. (* Q is var n *)
  - admit.
  - move=> P IHP Q IHQ R.



(* interesting case only for single beta step*)
Lemma construct_fN P Q : red_beta P Q -> 
  exists (fN : term -> term), red_beta Q (simple_map_term fN P).
Proof.
  elim.
  - admit.
  - move=> ?. exists id. admit. (* easy *)
  - move=> {}P {}Q R _ [fNPQ HfNPQ] _ [fNQR HfNQR].
    exists (funcomp (simple_map_term fNQR) fNPQ) => /=.
    apply: rt_trans; first by eassumption.
    rewrite -simple_map_simple_map_term.



(*
(* interesting case only for single beta step*)
Lemma construct_fN P Q : red_beta P Q -> 
  exists (fN : term -> term), 
    fN P = Q /\
    (forall P' Q', fN (pi P' Q') = pi (fN P') (fN Q')) /\
    (forall P', fN (ren_term shift P') = ren_term shift (fN P')).
Proof.
  elim.
  - admit.
  - move=> ?. by exists id.
  - move=> {}P {}Q R _ [fNPQ] [<-] [H1fNPQ H2fNPQ] _ [fNQR] [<-] [H1fNQR H2fNQR].
    exists (funcomp fNQR fNPQ) => /=. constructor; first done.
    constructor; by congruence.
Admitted.
*)

(* EXPERIMENTAL *)


(* EXPLICIT Pi-K APPROACH, arr is pi P Q such that 0 is fresh in Q *)
(* NOT NEEDED ?*)
(*
(* store pimple type information up to a term leaf *)
Inductive term' := 
  | atom : term -> term'
  | arr : term' -> term' -> term'.

Fixpoint simplify (xi: nat -> nat) (P: term) : term' :=
  match P with
  | pi P' Q' => 
      if fresh_inb 0 Q' 
        then arr (simplify xi P') (simplify (scons 0 xi) Q')
        else atom P
  | _ => atom P
  end.

  TODO 
(* make a term simple, remember non-simpel subterms as variables *)
Fixpoint prune2 (P: term') : term' :=
  match P with
  | atom P' => atom (var ())
  | pi P' Q' => 
      if fresh_inb 0 Q' 
        then SemiU.arr (prune2 xi P') (prune2 (scons 0 xi) Q')
        else SemiU.atom (encode_term (ren_term xi P))
  | _ => SemiU.atom (encode_term (ren_term xi P))
  end.
*)

   (*
normal form formulations

Lemma normal_formE {P} : normal_form P ->
  match P with
  | var _ => True
  | const _ => True 
  | app (lam _ _) _ => False
  | app P Q => normal_form P /\ normal_form Q
  | lam P Q => normal_form P /\ normal_form Q
  | pi P Q => normal_form P /\ normal_form Q
  end.
Proof.
  elim: P.
  - done.
  - done.
  - case.
    + move=> x _ Q. 

  move HR: (P) => R.
  elim: P R HR.
  - by move=> x R <-.
  -


  move=> Q. case.

(* a term is in normal form if it contains no beta-redex (lambda x : P. Q) R *)
Fixpoint is_normal_form (P : term) : bool :=
  match P with
  | var _ => true
  | const _ => true
  | app (lam _ _) _ => false
  | app P Q => is_normal_form P && is_normal_form Q
  | lam P Q => is_normal_form P && is_normal_form Q
  | pi P Q => is_normal_form P && is_normal_form Q
  end.



Lemma is_normal_formP {P} : reflect (normal_form P) (is_normal_form P).
Proof.
  elim: P => /=.
  - move=> x. constructor=> Q. move HP: (var x) => P HPQ.
    by case: HPQ HP.
  - move=> c. constructor=> Q. move HP: (const c) => P HPQ.
    by case: HPQ HP.
  - case => /=.
    + move=> x _ Q HQ. move HP: (app _ _) => P.
      apply : (iffP HQ).
    Search reflect.
    
    constructor.
*)
*)



(* SIMPLE SemiU APPROACH FAILS *)

(*

Require Undecidability.SemiUnification.SemiU.

(* make a term simple, remember non-simpel subterms as variables *)
Fixpoint prune2 (xi: nat -> nat) (P: term) : SemiU.term :=
  match P with
  | pi P' Q' => 
      if fresh_inb 0 Q' 
        then SemiU.arr (prune2 xi P') (prune2 (scons 0 xi) Q')
        else SemiU.atom (encode_term (ren_term xi P))
  | _ => SemiU.atom (encode_term (ren_term xi P))
  end.

(* pruning intanciated pruned instance (?) *)
(* "KEY LEMMA 2", tau is the resulting simple substitution *)
(* NOTE: fN is the relevant normalizer, xi3 = xi1 = id *)
Lemma key2_2 {fN : term -> term} {sigma xi1 xi2 P} : 
  (* fN preserves pi *)
  (forall P' Q', fN (pi P' Q') = pi (fN P') (fN Q')) ->
  (* fN preserves shifts; strong assumption *)
  (forall P', fN (ren_term shift P') = ren_term shift (fN P')) ->
  (* resulting simple valuation *)
  let tau := (fun x => prune2 xi2 (fN (subst_term sigma (decode_term x)))) in
  (* homomorphism *)
  SemiU.substitute tau (prune2 xi1 P) = prune2 xi2 (fN (subst_term (funcomp sigma xi1) P)).
Proof.
  move=> H1fN H2fN tau. subst tau.
  elim: P xi1 xi2 sigma.
  - move=> > /=. by rewrite encode_decode_term.
  - move=> > /=. by rewrite encode_decode_term.
  - move=> * /=. by rewrite encode_decode_term /= ?term_norm.
  - move=> P IHP Q IHQ xi1 xi2 sigma /=. rewrite encode_decode_term /= ?term_norm /=.
    congr (prune2 xi2 (fN (lam _ _))). apply: ext_term. by case.
    (* case pi P Q *)
  - move=> P IHP Q IHQ xi1 xi2 sigma /=.
    case HQ: (fresh_inb 0 Q).
    (* case (var 0) does not occur in Q *)
    + rewrite H1fN /=.

    have -> : fresh_inb 0 (fN (subst_term (up_term_term (funcomp sigma xi1)) Q)) = true.
    { admit. }
    move=> /=. congr SemiU.arr; first done.

    under [subst_term _ Q]ext_term => ? do rewrite up_term_term_funcomp.
    rewrite -IHQ.
*)